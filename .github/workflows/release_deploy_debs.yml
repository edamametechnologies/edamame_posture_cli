name: Build and publish for linux debs

on:
  workflow_dispatch:

# Auto cancel previous runs if they were not completed.
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

# Write permissions are required to upload the release asset.
permissions: write-all
    
jobs:
  build:
    runs-on: ${{ matrix.os }}-latest

    timeout-minutes: 90
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu
            arch: i386
            target: i686-unknown-linux-gnu
            deb_arch: i386
          - os: ubuntu
            arch: armhf
            target: armv7-unknown-linux-gnueabihf
            deb_arch: armhf
          - os: ubuntu
            arch: amd64
            target: x86_64-unknown-linux-gnu
            deb_arch: amd64
          - os: ubuntu
            arch: aarch64
            target: aarch64-unknown-linux-gnu
            deb_arch: arm64

    env:
      EDAMAME_APP_SENTRY: ${{ secrets.EDAMAME_APP_SENTRY }}
      PWNED_API_KEY: ${{ secrets.PWNED_API_KEY }}
      EDAMAME_TARGET: ${{ secrets.EDAMAME_TARGET }}
      EDAMAME_CORE_TARGET: ${{ secrets.EDAMAME_CORE_TARGET }}
      EDAMAME_CORE_SERVER: ${{ secrets.EDAMAME_CORE_SERVER }}
      EDAMAME_CA_PEM: ${{ secrets.EDAMAME_CA_PEM }}
      EDAMAME_CLIENT_PEM: ${{ secrets.EDAMAME_CLIENT_PEM }}
      EDAMAME_CLIENT_KEY: ${{ secrets.EDAMAME_CLIENT_KEY }}
      EDAMAME_SERVER_PEM: ${{ secrets.EDAMAME_SERVER_PEM }}
      EDAMAME_SERVER_KEY: ${{ secrets.EDAMAME_SERVER_KEY }}
      EDAMAME_CLIENT_CA_PEM: ${{ secrets.EDAMAME_CLIENT_CA_PEM }}
      LAMBDA_SIGNATURE: ${{ secrets.LAMBDA_SIGNATURE }}
      APPLE_APPSTORE_CONNECT_API_ISSUER_ID: ${{ secrets.APPLE_APPSTORE_CONNECT_API_ISSUER_ID }}
      APPLE_APPSTORE_CONNECT_API_KEY_ID: ${{ secrets.APPLE_APPSTORE_CONNECT_API_KEY_ID }}
      APPLE_APPSTORE_CONNECT_API_KEY: ${{ secrets.APPLE_APPSTORE_CONNECT_API_KEY }}
      MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.DEV_GITHUB_TOKEN_B64 }}
      MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      # Required for cross to not show warnings and fail
      CROSS_NO_WARNINGS: 0
      # Debug mode
      EDAMAME_LOG_LEVEL: debug
    
    steps:
      - name: Setup EDAMAME Posture
        uses: edamametechnologies/edamame_posture_action@v0
        with:
          edamame_user: ${{ vars.EDAMAME_POSTURE_USER }}
          edamame_domain: ${{ vars.EDAMAME_POSTURE_DOMAIN }}
          edamame_pin: ${{ secrets.EDAMAME_POSTURE_PIN }}
          edamame_id: ${{ github.run_id }}
          network_scan: true
          auto_remediate: true
          checkout: true
          # We are using the token of the private repo to checkout the public repo and properly wait for access to the private repo
          token: ${{ secrets.DEV_GITHUB_TOKEN }}
          wait_for_api: true
          wait_for_https: true

      - name: Configure Git Authentication to import private crates
        run: |
          git config --global user.email "dev@edamame.tech"
          git config --global user.name "EDAMAME Dev"
          git config --global url."https://edamamedev:${{ secrets.DEV_GITHUB_TOKEN }}@github.com/".insteadOf "https://github.com/"

      ############################################################################################
      # Setup
      ############################################################################################

      # Install Rust
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      # Install Cross for Linux
      - name: Install Cross for Linux
        run: cargo install cross --git https://github.com/cross-rs/cross

      ############################################################################################
      # Build
      ############################################################################################

      # Build application for Linux using cross
      - name: Build application for Linux using cross
        run: cross build --release --target ${{ matrix.target }}

      - name: Package Debian package with cargo deb
        run: |
          # Install binutils for objcopy and strip (configured in .cargo/config.toml)
          if [[ ${{ matrix.target }} == "armv7-unknown-linux-gnueabihf" ]]; then
            echo "Installing arm-linux-gnueabihf-binutils..."
            sudo apt-get install binutils-arm-linux-gnueabihf
          fi
          if [[ ${{ matrix.target }} == "aarch64-unknown-linux-gnu" ]]; then
            echo "Installing aarch64-linux-gnu-binutils..."
            sudo apt-get install binutils-aarch64-linux-gnu
          fi
          echo "Installing cargo-deb..."
          cargo install cargo-deb
          echo "Packaging .deb with cargo deb..."
          cargo deb --no-build --target ${{ matrix.target }}

      # We store the .deb as an artifact
      - name: Upload .deb artifact
        uses: actions/upload-artifact@v4
        with:
          name: deb-files-${{ matrix.deb_arch }}
          path: target/${{ matrix.target }}/debian/*.deb

      ############################################################################################
      # Release
      ############################################################################################

      # Main only
      - name: Check for existing release
        if: github.ref == 'refs/heads/main'
        id: get_release
        shell: bash
        run: |
          VERSION=$(grep '^version =' ./Cargo.toml | awk '{print $3}' | tr -d '"')
          echo "::set-output name=version::$VERSION"
          VERSION_TAG=v${VERSION}
          echo "::set-output name=tag::$VERSION_TAG"
          if [[ -n "$(gh release view $VERSION_TAG --repo ${{ github.repository }} --json id -q .id)" ]]; then
            echo "::set-output name=exists::true"
            echo "::set-output name=upload_url::$(gh release view $VERSION_TAG --json uploadUrl -q .uploadUrl )"
          else
            echo "::set-output name=exists::false"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Update the tag if it exists and points to a different commit
      - name: Update the tag if it exists and points to a different commit
        if: github.ref == 'refs/heads/main' && steps.get_release.outputs.exists == 'true'
        run: |
          gh release edit ${{ steps.get_release.outputs.tag }} --repo ${{ github.repository }} --target ${{ github.sha }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # Main only
      - name: Create release if it doesn't exist
        if: github.ref == 'refs/heads/main' && steps.get_release.outputs.exists != 'true'
        # This populates steps.get_release.outputs.upload_url with the upload_url of the release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.get_release.outputs.tag }}
          release_name: Release ${{ steps.get_release.outputs.tag }}
          draft: false
          prerelease: false

      # Main only
      - name: Upload asset to release
        if: github.ref == 'refs/heads/main'
        # Supports overwrite
        uses: shogo82148/actions-upload-release-asset@v1
        with:
          upload_url: ${{ steps.get_release.outputs.exists == 'true' && steps.get_release.outputs.upload_url || steps.create_release.outputs.upload_url }}
          # Path to the release for each target triplet
          asset_path: target/${{ matrix.target }}/release/edamame_posture${{ matrix.os == 'windows' && '.exe' || '' }}
          asset_name: edamame_posture-${{ steps.get_release.outputs.version }}-${{ matrix.target }}${{ matrix.os == 'windows' && '.exe' || '' }}
          asset_content_type: application/octet-stream
          overwrite: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload .deb asset to release
        uses: shogo82148/actions-upload-release-asset@v1
        with:
          upload_url: ${{ steps.get_release.outputs.exists == 'true' && steps.get_release.outputs.upload_url || steps.create_release.outputs.upload_url }}
          asset_path: target/${{ matrix.target }}/debian/edamame_posture_${{ steps.get_release.outputs.version }}-1_${{ matrix.deb_arch }}.deb
          asset_name: edamame_posture_${{ steps.get_release.outputs.version }}-1_${{ matrix.deb_arch }}.deb
          asset_content_type: application/vnd.debian.binary-package
          overwrite: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Dump EDAMAME Posture sessions
        uses: edamametechnologies/edamame_posture_action@v0
        with:
          dump_sessions_log: true

  # -----------------------------------------
  #  Final "combine" job 
  # -----------------------------------------
  combine:
    # This job needs the build job to finish
    needs: build
    runs-on: ubuntu-latest

    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}

    steps:
      - name: Setup EDAMAME Posture
        uses: edamametechnologies/edamame_posture_action@v0
        with:
          edamame_user: ${{ vars.EDAMAME_POSTURE_USER }}
          edamame_domain: ${{ vars.EDAMAME_POSTURE_DOMAIN }}
          edamame_pin: ${{ secrets.EDAMAME_POSTURE_PIN }}
          edamame_id: ${{ github.run_id }}
          network_scan: true
          auto_remediate: true
          checkout: true
          # We are using the token of the private repo to checkout the public repo and properly wait for access to the private repo
          token: ${{ secrets.DEV_GITHUB_TOKEN }}
          wait_for_api: true
          wait_for_https: true
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: repo/pool/main

      - name: Reorganize .deb files by ARCH
        shell: bash
        run: |
          for ARCH in amd64 arm64 armhf i386; do
            # If artifacts for that arch were downloaded, they'll be under:
            #   repo/pool/main/deb-files-<ARCH>/
            if [ -d "repo/pool/main/deb-files-$ARCH" ]; then
              mkdir -p "repo/pool/main/$ARCH"
              mv repo/pool/main/deb-files-$ARCH/*.deb "repo/pool/main/$ARCH/" || true
              rm -rf "repo/pool/main/deb-files-$ARCH"
            fi
          done

      - name: Download existing metadata
        run: |
          mkdir -p repo/dists/stable/main
          for ARCH in amd64 arm64 armhf i386; do
            mkdir -p "repo/dists/stable/main/binary-$ARCH"
            # Download and decompress existing Packages.gz if it exists
            if aws s3 cp "s3://edamame/repo/dists/stable/main/binary-$ARCH/Packages.gz" \
              "repo/dists/stable/main/binary-$ARCH/Packages.gz" 2>/dev/null; then
              gunzip -f "repo/dists/stable/main/binary-$ARCH/Packages.gz"
            else
              touch "repo/dists/stable/main/binary-$ARCH/Packages"
            fi
          done

          # Download Release files
          aws s3 cp s3://edamame/repo/dists/stable/Release repo/dists/stable/Release 2>/dev/null || true
          aws s3 cp s3://edamame/repo/dists/stable/Release.gpg repo/dists/stable/Release.gpg 2>/dev/null || true
          aws s3 cp s3://edamame/repo/dists/stable/InRelease repo/dists/stable/InRelease 2>/dev/null || true

      - name: Combine .deb stanzas
        run: |
          for ARCH in amd64 arm64 armhf i386; do
            DEB_DIR="repo/pool/main/$ARCH"
            PACKAGES_FILE="repo/dists/stable/main/binary-$ARCH/Packages"
            
            # Only proceed if we have .deb files
            if [ -d "$DEB_DIR" ] && [ -n "$(ls "$DEB_DIR"/*.deb 2>/dev/null)" ]; then
              echo "Processing new packages for $ARCH..."
              
              # Verify .deb files are valid
              for deb in $DEB_DIR/*.deb; do
                dpkg-deb -I "$deb" || echo "Warning: Invalid .deb file: $deb"
              done

              # Create temporary files
              TEMP_NEW=$(mktemp)
              TEMP_MERGED=$(mktemp)
              
              # Generate stanzas for new packages
              # Change directory to where the .deb files live
              pushd "$DEB_DIR"
              dpkg-scanpackages --multiversion . > "$TEMP_NEW"
              popd

              # Process existing and new packages to remove duplicates
              # Using awk to identify package stanzas and keep the latest version
              awk -v RS='\n\n' -v ORS='\n\n' '
                {
                  # Extract package name and version
                  pkg = version = ""
                  for (i=1; i<=NF; i++) {
                    if ($i ~ /^Package:/) pkg = substr($i, 10)
                    if ($i ~ /^Version:/) version = substr($i, 10)
                  }
                  if (pkg && version) {
                    key = pkg "-" version
                    if (!(key in seen) || $0 > seen[key]) {
                      seen[key] = $0
                    }
                  }
                }
                END {
                  for (key in seen) {
                    print seen[key]
                  }
                }' "$PACKAGES_FILE" "$TEMP_NEW" > "$TEMP_MERGED"
              
              # Replace the old Packages file with merged content
              mv "$TEMP_MERGED" "$PACKAGES_FILE"
              
              # Clean up temp files
              rm -f "$TEMP_NEW"
              
              # Compress the updated Packages file
              gzip -9f "$PACKAGES_FILE"
            fi
          done

      - name: Update Release file and sign
        env:
          GPG_PRIVATE_KEY_B64: ${{ secrets.GPG_PRIVATE_KEY_B64 }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          # Import GPG key
          echo "$GPG_PRIVATE_KEY_B64" | base64 -d | gpg --batch --import

          # Create all required directories
          mkdir -p repo/dists/stable/main
          for ARCH in amd64 arm64 armhf i386; do
            mkdir -p "repo/dists/stable/main/binary-$ARCH"
          done

          # Export public key to both locations
          gpg --batch --yes --export --armor > repo/dists/stable/public.key
          mkdir -p repo/pool
          gpg --batch --yes --export --armor > repo/pool/public.key

          # Create or update Release file
          mkdir -p repo/dists/stable
          echo "Origin: EDAMAME" > repo/dists/stable/Release
          echo "Label: EDAMAME Repository" >> repo/dists/stable/Release
          echo "Suite: stable" >> repo/dists/stable/Release
          echo "Codename: stable" >> repo/dists/stable/Release
          echo "Architectures: amd64 arm64 armhf i386" >> repo/dists/stable/Release
          echo "Components: main" >> repo/dists/stable/Release
          echo "Date: $(date -u '+%a, %d %b %Y %H:%M:%S UTC')" >> repo/dists/stable/Release

          # Add MD5Sum:
          echo "MD5Sum:" >> repo/dists/stable/Release
          for ARCH in amd64 arm64 armhf i386; do
            PKG_GZ="repo/dists/stable/main/binary-$ARCH/Packages.gz"
            PKG_TXT="repo/dists/stable/main/binary-$ARCH/Packages"

            if [ -f "$PKG_GZ" ]; then
              SIZE=$(stat -c%s "$PKG_GZ")
              MD5=$(md5sum "$PKG_GZ" | cut -d' ' -f1)
              echo " $MD5 $SIZE main/binary-$ARCH/Packages.gz" >> repo/dists/stable/Release
            fi
            if [ -f "$PKG_TXT" ]; then
              SIZE=$(stat -c%s "$PKG_TXT")
              MD5=$(md5sum "$PKG_TXT" | cut -d' ' -f1)
              echo " $MD5 $SIZE main/binary-$ARCH/Packages" >> repo/dists/stable/Release
            fi
          done

          # Add SHA256:
          echo "SHA256:" >> repo/dists/stable/Release
          for ARCH in amd64 arm64 armhf i386; do
            PKG_GZ="repo/dists/stable/main/binary-$ARCH/Packages.gz"
            PKG_TXT="repo/dists/stable/main/binary-$ARCH/Packages"

            if [ -f "$PKG_GZ" ]; then
              SIZE=$(stat -c%s "$PKG_GZ")
              SHA256=$(sha256sum "$PKG_GZ" | cut -d' ' -f1)
              echo " $SHA256 $SIZE main/binary-$ARCH/Packages.gz" >> repo/dists/stable/Release
            fi
            if [ -f "$PKG_TXT" ]; then
              SIZE=$(stat -c%s "$PKG_TXT")
              SHA256=$(sha256sum "$PKG_TXT" | cut -d' ' -f1)
              echo " $SHA256 $SIZE main/binary-$ARCH/Packages" >> repo/dists/stable/Release
            fi
          done

          # Sign Release file
          cd repo/dists/stable
          rm -f Release.gpg InRelease
          gpg --batch --yes --passphrase "$GPG_PASSPHRASE" --pinentry-mode loopback -abs -o Release.gpg Release
          gpg --batch --yes --passphrase "$GPG_PASSPHRASE" --pinentry-mode loopback -a -s --clearsign --output InRelease Release
      
      - name: Upload updated repository
        run: |
          # Ensure all directories exist before upload
          for ARCH in amd64 arm64 armhf i386; do
            mkdir -p "repo/pool/main/$ARCH"
            mkdir -p "repo/dists/stable/main/binary-$ARCH"
          done

          # Upload new .deb files
          for ARCH in amd64 arm64 armhf i386; do
            DEB_DIR="repo/pool/main/$ARCH"
            if [ -d "$DEB_DIR" ]; then
              aws s3 cp "$DEB_DIR/" "s3://edamame/repo/pool/main/$ARCH/" \
                --acl public-read --recursive
            fi
          done

          # Upload updated metadata (Packages*, Release, Release.gpg, etc.) + public key
          aws s3 cp repo/dists/ s3://edamame/repo/dists/ \
            --acl public-read --recursive

          # Create a more friendly URL for the public key
          aws s3 cp repo/dists/stable/public.key s3://edamame/repo/public.key \
            --acl public-read

      - name: Verify uploads
        run: |
          # Verify uploads
            curl -sI "https://edamame.s3.eu-west-1.amazonaws.com/repo/dists/stable/main/binary-$ARCH/Packages.gz" \
              | grep "HTTP/"
                | grep "HTTP/"
            done
          done